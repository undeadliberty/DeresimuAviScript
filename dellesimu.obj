--track0:属性,0,3,0,1
--track1:落下速度,1,10,8,0.1
--track2:開始位置,0,1500,0,0.01
--file:

obj.load("image",obj.getinfo("script_path").."image\\ui\\ring_lower.png")
obj.effect("クリッピング","上",142*obj.track0,"下",142*(3-obj.track0),"中心の位置を変更",1)
obj.draw(0,240,0,0.96)


local function GetPosition(time,start,goal)
    local k=0.18
    if(time<k)then
        k=time
    end
    local y=3000*(k-0.1)*(k-0.1)-335
    if(time>k)then
        y= 240 +(y-240)*(1-time)/(1-k)
    end
    k =0.5
    local z=400*k*((1+k)/(time+k)-1)
    local x=197*(start*z/400+goal*(1-z/400)-3)
    local size = 1-(1-time)*(1-time)
    return x,y,z,size
end
local function Drawnote(type,start,goal,time)--種類、出現位置、到着位置、経過時間
    obj.load("image",obj.getinfo("script_path").."image\\note\\notes.png")
    local nox,noy,noz,size =GetPosition(time,start,goal)
    if(type=='1')then
        type=220
    elseif(type=='2')then
        type=0
    elseif(type=='3')then
        type=330
    elseif(type=='4')then
        type=110
    elseif(type=='5')then
        type=440
    else
        type=0
    end
    obj.drawpoly(nox-77*size,noy-55*size,noz,nox+77*size,noy-55*size,noz,nox+77*size,noy+55*size,noz,nox-77*size,noy+55*size,noz,154*obj.track0,type,154*(1+obj.track0),type,154*(1+obj.track0),type+110,154*obj.track0,type+110)
    return nil
end
local function Drawlong(start,goal,st,gt)
    local k=40
    local time=0
    local k2=0
    obj.setoption("drawtarget","tempbuffer",1280,720)
    obj.setoption("blend","alpha_add")
    if(gt>1)then
        k2=(gt-1)/3
    end
    for i=0,k-1 do
        if(st < (i+1)/k and i/k < gt) then
            obj.load("figure","四角形",HSV(0,0,80))
            if(st<i/k) then
                time=i/k
            else
                time=st
            end
            local x1,y1,z1,size1 =GetPosition(time,start,goal)
            if((i+1)/k<gt) then
                time=(i+1)/k
            else
                time=gt
            end
            local x2,y2,z2,size2 =GetPosition(time,start,goal)
            obj.setoption("drawtarget","tempbuffer")
            if(obj.track0==3)then
                obj.effect("グラデーション","color",HSV(math.floor((i/k+k2)*360+goal*20+100)%360,30,90),"color2",HSV(math.floor(((i+1)/k+k2)*360+goal*20+100)%360,30,90))
            end
            obj.drawpoly(x1-48*size1,y1,z1,x1+48*size1,y1,z1,x2+48*size2,y2,z2,x2-48*size2,y2,z2)
        end
    end
    obj.setoption("drawtarget","framebuffer")  --これがないと次のobj.drawでも仮想バッファに描画してしまう
    obj.load("tempbuffer")
    obj.draw(0,0,0,1,0.8) 
end
local function Drawflick(time1,start1,goal1,time2,start2,goal2)
    local k2=0
    local x1,y1,z1,size1 =GetPosition(time1,start1,goal1)
    if(time1>1)then
        x1,k2,k2,size1 =GetPosition(1,start1,goal1)
        k2=time1-1    
    end
    if(time2<0)then
        time2=0
    end
    local x2,y2,z2,size2 =GetPosition(time2,start2,goal2)
    local sinx=(y1-y2)/math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
    local cosx=(x1-x2)/math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
    obj.setoption("drawtarget","tempbuffer",1280,720)
    obj.load("figure","四角形",HSV(0,0,80))
    obj.drawpoly(x1-24*size1*sinx,y1+24*size1*cosx,z1,x1+24*size1*sinx,y1-24*size1*cosx,z1,x2+24*size2*sinx,y2-24*size2*cosx,z2,x2-24*size2*sinx,y2+24*size2*cosx,z2)
    obj.load("tempbuffer")
    if(obj.track0==3)then
        obj.setoption("drawtarget","tempbuffer",2560,720)
        obj.setoption("blend","alpha_add")
        obj.draw(640,0)
        local k=60
        for i=1,k-1 do
            local y= 600*i/k -300
            obj.load("tempbuffer",1280,y+360,1280,500/k+2)
            obj.effect("グラデーション","color",HSV(math.floor((i/k+k2)*360+goal1*20+100)%360,30,90),"color2",HSV(math.floor(((i+1)/k+k2)*360+goal1*20+100)%360,30,90))
            obj.setoption("drawtarget","tempbuffer")
            obj.setoption("blend","alpha_add")
            obj.draw(-640,y+250/k+1)    
        end
        obj.load("tempbuffer",0,0,1280,720)
    end
    obj.setoption("drawtarget","framebuffer")  --これがないと次のobj.drawでも仮想バッファに描画してしまう
    obj.effect("斜めクリッピング","中心Y",-30,"ぼかし",40,"幅",540)
    obj.draw(0,0,0,1,0.8)
end
local combo=0
local bpm={}
local offset=0
local notime = obj.track2+obj.time

local speed=3-0.3*obj.track1
if obj.track1>4.0 then
    speed=speed + 0.1*(obj.track1-4)
    if obj.track1>9.0 then
        speed=speed- 0.1*(obj.track1-9)
    end
end

local function GetTimeFromStep(step)
    local time=offset
    local i=0
    local j=1
    for line =1, #bpm do
        if(bpm[line][1]<step) then
            time=time+(bpm[line][1]-i)*240/j
            i=bpm[line][1]
            j=bpm[line][2]
        else
            time=time+(step-i)*240/j
            return time
        end
    end
    time=time+(step-i)*240/j
        return time
end

local longstack={}
local flickstack={}
local flicklast={}
local longpair={}
local flickpair={}
local notestack={}

for line in io.lines(file) do
    if(string.match(line,"^#BPM")) then
        bpm[1]={0,tonumber(string.match(line,"[0-9.]+"))}
    elseif(string.match(line,"^#Offset")) then
        offset= tonumber(string.match(line,"[0-9.]+"))/1000
    elseif(string.match(line,"^#ChangeBPM")) then
        local a,b = string.match(line,"([0-9.]+),%s*([0-9.]+)")
        table.insert(bpm,{tonumber(a),tonumber(b)})
    elseif(string.match(line,"^#%d")) then
        local canel,step,notes,sg,eg=string.match(line,"^#(%d+),(%d+):(%d+):(%d+):?(%d*)")
        if(not tonumber(eg))then
            eg=sg    
        end
        canel=tonumber(canel)
        step=tonumber(step)
        local j=1
        local k=0
        for i in string.gmatch(notes,"%d") do
            local t=GetTimeFromStep(step+k/#notes)
            if(i~='0')then
                local start=tonumber(string.sub(sg,j,j))
                local goal=tonumber(string.sub(eg,j,j))
                if(notime > t) then                   
                    if(not(longstack[goal] and longstack[goal][1] < (notime-t)/speed+1))then
                        longstack[goal]={(notime-t)/speed+1,i}
                    end
                    if(not(flickstack[canel] and flickstack[canel][1] < (notime-t)/speed+1))then
                        flickstack[canel]={(notime-t)/speed+1,i,start,goal}
                    end
                    combo=combo+1
                elseif(t-notime<speed)then
                    table.insert(notestack,{(notime-t)/speed+1,i,start,goal,canel})
                else
                    if(not(longstack[goal+5] and longstack[goal+5][1] > (notime-t)/speed+1))then
                        longstack[goal+5]={(notime-t)/speed+1,i,start}
                    end
                    if(not(flicklast[canel] and flicklast[canel][1] > (notime-t)/speed+1))then
                        flicklast[canel+1]={(notime-t)/speed+1,i,start,goal}
                    end    
                end
                j=j+1
            end
            k=k+1
        end
    end
end

table.sort(notestack,function(a,b)return a[1]>b[1] end)
for i=1,5 do
    if(longstack[i] and longstack[i][2]=='4') then
        longstack[i]=longstack[i][1]   
    else
        longstack[i]=nil
    end
end
for i=1,#notestack do --time,type,start,goal,canel
    local time = notestack[i][1]
    local type = notestack[i][2]
    local start = notestack[i][3]
    local goal = notestack[i][4]
    local canel = notestack[i][5]
    if(longstack[goal])then
        table.insert(longpair,{start,goal,time,longstack[goal]})
        longstack[goal]=nil
        if(type=='2')then
            notestack[i][2]='4'
        end
    elseif(type=='4')then
        longstack[goal]=time
    end
    if(flickstack[canel])then
        if(type=='1' or type=='3')then
            if(canel%4>1 or (flickstack[canel][2]=='1' and flickstack[canel][4]>goal)or(flickstack[canel][2]=='3' and flickstack[canel][4]<goal))then
                table.insert(flickpair,{flickstack[canel][1],flickstack[canel][3],flickstack[canel][4],time,start,goal})
            end
        end
        flickstack[canel]=nil
    end
    if(type=='1' or type=='3')then
        flickstack[canel]={time,type,start,goal}
    end    
end
for i=1,5 do
    if(longstack[i] and longstack[i+5]) then
        table.insert(longpair,{longstack[i+5][3],i,longstack[i+5][1],longstack[i]})
    end
end
for i=1,#longpair do
    --debug_print(longpair[i][1]..','..longpair[i][2]..','..longpair[i][3]..','..longpair[i][4])
    Drawlong(longpair[i][1],longpair[i][2],longpair[i][3],longpair[i][4])
end
for i=1,#flickpair do
    --debug_print(flickpair[i][1]..','..flickpair[i][2]..','..flickpair[i][3]..','..flickpair[i][4]..','..flickpair[i][5]..','..flickpair[i][6])
    Drawflick(flickpair[i][1],flickpair[i][2],flickpair[i][3],flickpair[i][4],flickpair[i][5],flickpair[i][6])
end

for i=1,#notestack do
    if(i<#notestack and notestack[i][1]==notestack[i+1][1])then
        time=notestack[i][1]
        local x1,y1,z1,size =GetPosition(time,notestack[i][3],notestack[i][4])
        local x2 =GetPosition(time,notestack[i+1][3],notestack[i+1][4])
        if(x1 > x2)then
            x1,x2=x2,x1
        end
        local size = 1-(1-time)*(1-time)
        obj.load("figure","四角形",0xffffff,10)
        obj.effect("グラデーション","type",3,"幅",10)
        obj.drawpoly(x1+48*size,y1-5*size,z1,x2-48*size,y1-5*size,z1,x2-48*size,y1+5*size,z1,x1+48*size,y1+5*size,z1)
    end
    Drawnote(notestack[i][2],notestack[i][3],notestack[i][4],notestack[i][1])
end
if(combo>1) then
    obj.setfont("Arial Black",100,4,0xffffff,0xffb400)
    obj.load("text",combo)
    obj.effect("リサイズ","X",90)
    obj.draw(410,-230)
    obj.setfont("Arial Black",40,3,0xffffff,0xffb400)
    obj.load("text","COMBO")
    obj.effect("リサイズ","X",90)
    obj.draw(410,-165)    
end

